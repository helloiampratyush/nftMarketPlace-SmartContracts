"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.combineOracleSignatures = exports.recoverAddressFromSignature = exports.personalSign = exports.generateOracleSignatures = exports.encodeOracleRequest = exports.encodeOracleSignatures = exports.generateSAID = exports.encodeServiceAgreement = exports.initiateSAParams = exports.assertServiceAgreementEmpty = exports.serviceAgreement = void 0;
const tslib_1 = require("tslib");
/**
 * @packageDocumentation
 *
 * This file provides convenience functions to interact with existing solidity contract abstraction libraries, such as
 * @truffle/contract and ethers.js specifically for our `Coordinator.sol` solidity smart contract.
 */
const chai_1 = require("chai");
const ethers_1 = require("ethers");
const helpers_1 = require("../helpers");
const matchers = tslib_1.__importStar(require("../matchers"));
/**
 * Create a service agreement with sane testing defaults
 *
 * @param overrides Values to override service agreement defaults
 */
function serviceAgreement(overrides) {
    const agreement = {
        payment: helpers_1.bigNum('1000000000000000000'),
        expiration: helpers_1.bigNum(300),
        endAt: helpers_1.sixMonthsFromNow(),
        oracles: [],
        requestDigest: '0xbadc0de5badc0de5badc0de5badc0de5badc0de5badc0de5badc0de5badc0de5',
        aggregator: '0x3141592653589793238462643383279502884197',
        aggInitiateJobSelector: '0xd43a12f6',
        aggFulfillSelector: '0x9760168f',
        ...overrides,
    };
    return agreement;
}
exports.serviceAgreement = serviceAgreement;
/**
 * Check that all values for the struct at this SAID have default values.
 *
 * For example, when an invalid service agreement initialization request is made to a `Coordinator`, we want to make sure that
 * it did not initialize its service agreement struct to any value, hence checking for it being empty.
 *
 * @param coordinator The coordinator contract
 * @param serviceAgreementID The service agreement ID
 *
 * @throws when any of payment, expiration, endAt, requestDigest are non-empty
 */
function assertServiceAgreementEmpty(sa) {
    matchers.bigNum(sa.payment, helpers_1.bigNum(0), 'service agreement is not absent');
    matchers.bigNum(sa.expiration, helpers_1.bigNum(0), 'service agreement is not absent');
    matchers.bigNum(sa.endAt, helpers_1.bigNum(0), 'service agreement is not absent');
    chai_1.assert.equal(sa.requestDigest, '0x0000000000000000000000000000000000000000000000000000000000000000');
}
exports.assertServiceAgreementEmpty = assertServiceAgreementEmpty;
/**
 * Create parameters needed for the
 * ```solidity
 *   function initiateServiceAgreement(
 *    bytes memory _serviceAgreementData,
 *    bytes memory _oracleSignaturesData
 *  )
 * ```
 * method of the `Coordinator.sol` contract
 *
 * @param overrides Values to override the defaults for creating a service agreement
 */
async function initiateSAParams(overrides) {
    const sa = serviceAgreement(overrides);
    const signatures = await generateOracleSignatures(sa);
    return [encodeServiceAgreement(sa), encodeOracleSignatures(signatures)];
}
exports.initiateSAParams = initiateSAParams;
const SERVICE_AGREEMENT_TYPES = [
    'uint256',
    'uint256',
    'uint256',
    'address[]',
    'bytes32',
    'address',
    'bytes4',
    'bytes4',
];
/**
 * ABI encode a service agreement object
 *
 * @param sa The service agreement to encode
 */
function encodeServiceAgreement(sa) {
    return ethers_1.ethers.utils.defaultAbiCoder.encode(SERVICE_AGREEMENT_TYPES, serviceAgreementValues(sa));
}
exports.encodeServiceAgreement = encodeServiceAgreement;
/**
 * Generate the unique identifier of a service agreement by computing its
 * digest.
 *
 * @param sa The service agreement to compute the digest of
 */
function generateSAID(sa) {
    return ethers_1.ethers.utils.solidityKeccak256(SERVICE_AGREEMENT_TYPES, serviceAgreementValues(sa));
}
exports.generateSAID = generateSAID;
/**
 * ABI encode the javascript representation of OracleSignatures
 *```solidity
 *  struct OracleSignatures {
 *    uint8[] vs;
 *    bytes32[] rs;
 *    bytes32[] ss;
 *  }
 * ```
 *
 * @param os The oracle signatures to ABI encode
 */
function encodeOracleSignatures(os) {
    const ORACLE_SIGNATURES_TYPES = ['uint8[]', 'bytes32[]', 'bytes32[]'];
    const osValues = [os.vs, os.rs, os.ss];
    return ethers_1.ethers.utils.defaultAbiCoder.encode(ORACLE_SIGNATURES_TYPES, osValues);
}
exports.encodeOracleSignatures = encodeOracleSignatures;
/**
 * Abi encode the oracleRequest() method for `Coordinator.sol`
 * ```solidity
 *  function oracleRequest(
 *    address _sender,
 *    uint256 _amount,
 *    bytes32 _sAId,
 *    address _callbackAddress,
 *    bytes4 _callbackFunctionId,
 *    uint256 _nonce,
 *    uint256 _dataVersion,
 *    bytes calldata _data
 *  )
 * ```
 *
 * @param sAID The service agreement ID
 * @param callbackAddr The callback contract address for the response
 * @param callbackFunctionId The callback function id for the response
 * @param nonce The nonce sent by the requester
 * @param data The CBOR payload of the request
 */
function encodeOracleRequest(specId, to, fHash, nonce, dataBytes) {
    const oracleRequestSighash = '0x40429946';
    const oracleRequestInputs = [
        { name: '_sender', type: 'address' },
        { name: '_amount', type: 'uint256' },
        { name: '_sAId', type: 'bytes32' },
        { name: '_callbackAddress', type: 'address' },
        { name: '_callbackFunctionId', type: 'bytes4' },
        { name: '_nonce', type: 'uint256' },
        { name: '_dataVersion', type: 'uint256' },
        { name: '_data', type: 'bytes' },
    ];
    const encodedParams = ethers_1.ethers.utils.defaultAbiCoder.encode(oracleRequestInputs.map((i) => i.type), [ethers_1.ethers.constants.AddressZero, 0, specId, to, fHash, nonce, 1, dataBytes]);
    return `${oracleRequestSighash}${helpers_1.stripHexPrefix(encodedParams)}`;
}
exports.encodeOracleRequest = encodeOracleRequest;
/**
 * Generates the oracle signatures on a ServiceAgreement
 *
 * @param serviceAgreement The service agreement to sign
 * @param signers The list oracles that will sign the service agreement
 */
async function generateOracleSignatures(serviceAgreement) {
    const sAID = generateSAID(serviceAgreement);
    const signatures = [];
    for (let i = 0; i < serviceAgreement.oracles.length; i++) {
        const oracle = serviceAgreement.oracles[i];
        if (!(oracle instanceof ethers_1.ethers.Wallet)) {
            throw Error('cannot generate signatures without oracle wallets');
        }
        const oracleSignature = await personalSign(sAID, oracle);
        const requestDigestAddr = recoverAddressFromSignature(sAID, oracleSignature);
        chai_1.assert.equal(oracle.address, requestDigestAddr);
        signatures.push(oracleSignature);
    }
    return combineOracleSignatures(signatures);
}
exports.generateOracleSignatures = generateOracleSignatures;
/**
 * Signs a message according to ethereum specs by first appending
 * "\x19Ethereum Signed Message:\n' + <message.length>" to the message
 *
 * @param message The message to sign - either a Buffer or a hex string
 * @param wallet The wallet of the signer
 */
async function personalSign(message, wallet) {
    if (message instanceof String && !ethers_1.utils.isHexString(message)) {
        throw Error(`The message ${message} is not a valid hex string`);
    }
    const flatSig = await wallet.signMessage(ethers_1.utils.arrayify(message));
    const splitSignature = ethers_1.utils.splitSignature(flatSig);
    function assertIsSignature(sig) {
        if (!sig.v)
            throw Error(`Could not extract v from signature`);
    }
    assertIsSignature(splitSignature);
    return splitSignature;
}
exports.personalSign = personalSign;
/**
 * Recovers the address of the signer of a message
 *
 * @param message The message that was signed
 * @param signature The signature on the message
 */
function recoverAddressFromSignature(message, signature) {
    const messageBuff = ethers_1.utils.arrayify(message);
    return ethers_1.utils.verifyMessage(messageBuff, signature);
}
exports.recoverAddressFromSignature = recoverAddressFromSignature;
/**
 * Combine v, r, and s params of multiple signatures into format expected by contracts
 *
 * @param signatures The list of signatures to combine
 */
function combineOracleSignatures(signatures) {
    return signatures.reduce((prev, { v, r, s }) => {
        prev.vs.push(v);
        prev.rs.push(r);
        prev.ss.push(s);
        return prev;
    }, { vs: [], rs: [], ss: [] });
}
exports.combineOracleSignatures = combineOracleSignatures;
function serviceAgreementValues(sa) {
    return [
        sa.payment,
        sa.expiration,
        sa.endAt,
        sa.oracles.map((o) => (o instanceof ethers_1.ethers.Wallet ? o.address : o)),
        sa.requestDigest,
        sa.aggregator,
        sa.aggInitiateJobSelector,
        sa.aggFulfillSelector,
    ];
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29vcmRpbmF0b3IuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvY29udHJhY3RzL2Nvb3JkaW5hdG9yLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFBQTs7Ozs7R0FLRztBQUNILCtCQUE2QjtBQUM3QixtQ0FBc0M7QUFFdEMsd0NBQXFFO0FBQ3JFLDhEQUF1QztBQXlGdkM7Ozs7R0FJRztBQUNILFNBQWdCLGdCQUFnQixDQUM5QixTQUFvQztJQUVwQyxNQUFNLFNBQVMsR0FBcUI7UUFDbEMsT0FBTyxFQUFFLGdCQUFNLENBQUMscUJBQXFCLENBQUM7UUFDdEMsVUFBVSxFQUFFLGdCQUFNLENBQUMsR0FBRyxDQUFDO1FBQ3ZCLEtBQUssRUFBRSwwQkFBZ0IsRUFBRTtRQUN6QixPQUFPLEVBQUUsRUFBRTtRQUNYLGFBQWEsRUFDWCxvRUFBb0U7UUFDdEUsVUFBVSxFQUFFLDRDQUE0QztRQUN4RCxzQkFBc0IsRUFBRSxZQUFZO1FBQ3BDLGtCQUFrQixFQUFFLFlBQVk7UUFDaEMsR0FBRyxTQUFTO0tBQ2IsQ0FBQTtJQUVELE9BQU8sU0FBUyxDQUFBO0FBQ2xCLENBQUM7QUFqQkQsNENBaUJDO0FBRUQ7Ozs7Ozs7Ozs7R0FVRztBQUNILFNBQWdCLDJCQUEyQixDQUN6QyxFQUFxQztJQUVyQyxRQUFRLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxPQUFPLEVBQUUsZ0JBQU0sQ0FBQyxDQUFDLENBQUMsRUFBRSxpQ0FBaUMsQ0FBQyxDQUFBO0lBQ3pFLFFBQVEsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLFVBQVUsRUFBRSxnQkFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLGlDQUFpQyxDQUFDLENBQUE7SUFDNUUsUUFBUSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsS0FBSyxFQUFFLGdCQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsaUNBQWlDLENBQUMsQ0FBQTtJQUN2RSxhQUFNLENBQUMsS0FBSyxDQUNWLEVBQUUsQ0FB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QUFBO1FBRWYsT0FBTyxJQUFJLENBQUE7SUFDYixDQUFDLEVBQ0QsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxDQUMzQixDQUFBO0FBQ0gsQ0FBQztBQWJELDBEQWFDO0FBRUQsU0FBUyxzQkFBc0IsQ0FBQyxFQUFvQjtJQUNsRCxPQUFPO1FBQ0wsRUFBRSxDQUFDLE9BQU87UUFDVixFQUFFLENBQUMsVUFBVTtRQUNiLEVBQUUsQ0FBQyxLQUFLO1FBQ1IsRUFBRSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxZQUFZLGVBQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ25FLEVBQUUsQ0FBQyxhQUFhO1FBQ2hCLEVBQUUsQ0FBQyxVQUFVO1FBQ2IsRUFBRSxDQUFDLHNCQUFzQjtRQUN6QixFQUFFLENBQUMsa0JBQWtCO0tBQ3RCLENBQUE7QUFDSCxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAcGFja2FnZURvY3VtZW50YXRpb25cbiAqXG4gKiBUaGlzIGZpbGUgcHJvdmlkZXMgY29udmVuaWVuY2UgZnVuY3Rpb25zIHRvIGludGVyYWN0IHdpdGggZXhpc3Rpbmcgc29saWRpdHkgY29udHJhY3QgYWJzdHJhY3Rpb24gbGlicmFyaWVzLCBzdWNoIGFzXG4gKiBAdHJ1ZmZsZS9jb250cmFjdCBhbmQgZXRoZXJzLmpzIHNwZWNpZmljYWxseSBmb3Igb3VyIGBDb29yZGluYXRvci5zb2xgIHNvbGlkaXR5IHNtYXJ0IGNvbnRyYWN0LlxuICovXG5pbXBvcnQgeyBhc3NlcnQgfSBmcm9tICdjaGFpJ1xuaW1wb3J0IHsgZXRoZXJzLCB1dGlscyB9IGZyb20gJ2V0aGVycydcbmltcG9ydCB7IEJpZ051bWJlcmlzaCB9IGZyb20gJ2V0aGVycy91dGlscydcbmltcG9ydCB7IGJpZ051bSwgc2l4TW9udGhzRnJvbU5vdywgc3RyaXBIZXhQcmVmaXggfSBmcm9tICcuLi9oZWxwZXJzJ1xuaW1wb3J0ICogYXMgbWF0Y2hlcnMgZnJvbSAnLi4vbWF0Y2hlcnMnXG5cbmV4cG9ydCBpbnRlcmZhY2UgU2VydmljZUFncmVlbWVudCB7XG4gIC8qKlxuICAgKiBQcmljZSBpbiBMSU5LIHRvIHJlcXVlc3QgYSByZXBvcnQgYmFzZWQgb24gdGhpcyBhZ3JlZW1lbnRcbiAgICpcbiAgICogQHNvbGZvcm1hdCB1aW50MjU2XG4gICAqL1xuICBwYXltZW50OiBldGhlcnMudXRpbHMuQmlnTnVtYmVyaXNoXG4gIC8qKlxuICAgKiBFeHBpcmF0aW9uIGlzIHRoZSBhbW91bnQgb2YgdGltZSBhbiBvcmFjbGUgaGFzIHRvIGFuc3dlciBhIHJlcXVlc3RcbiAgICpcbiAgICogQHNvbGZvcm1hdCB1aW50MjU2XG4gICAqL1xuICBleHBpcmF0aW9uOiBldGhlcnMudXRpbHMuQmlnTnVtYmVyaXNoXG4gIC8qKlxuICAgKiBUaGUgc2VydmljZSBhZ3JlZW1lbnQgaXMgdmFsaWQgdW50aWwgdGhpcyB0aW1lXG4gICAqXG4gICAqIEBzb2xmb3JtYXQgdWludDI1NlxuICAgKi9cbiAgZW5kQXQ6IGV0aGVycy51dGlscy5CaWdOdW1iZXJpc2hcbiAgLyoqXG4gICAqIEFuIGFycmF5IG9mIG9yYWNsZSBhZGRyZXNzZXMgdG8gdXNlIHdpdGhpbiB0aGUgcHJvY2VzcyBvZiBhZ2dyZWdhdGlvblxuICAgKlxuICAgKiBAc29sZm9ybWF0IGFkZHJlc3NbXVxuICAgKi9cbiAgb3JhY2xlczogKHN0cmluZyB8IGV0aGVycy5XYWxsZXQpW11cbiAgLyoqXG4gICAqIFRoaXMgZWZmZWN0aXZlbHkgZnVuY3Rpb25zIGFzIGFuIElEIHRhZyBmb3IgdGhlIG9mZi1jaGFpbiBqb2Igb2YgdGhlXG4gICAqIHNlcnZpY2UgYWdyZWVtZW50LiBJdCBpcyBjYWxjdWxhdGVkIGFzIHRoZSBrZWNjYWsyNTYgaGFzaCBvZiB0aGVcbiAgICogbm9ybWFsaXplZCBKU09OIHJlcXVlc3QgdG8gY3JlYXRlIHRoZSBTZXJ2aWNlQWdyZWVtZW50LCBidXQgdGhhdCBpZGVudGl0eVxuICAgKiBpcyB1bnVzZWQsIGFuZCBpdHMgdmFsdWUgaXMgZXNzZW50aWFsbHkgYXJiaXRyYXJ5LlxuICAgKlxuICAgKiBAc29sZm9ybWF0IGJ5dGVzMzJcbiAgICovXG4gIHJlcXVlc3REaWdlc3Q6IHN0cmluZ1xuXG4gIC8qKlxuICAgKiAgU3BlY2lmaWNhdGlvbiBvZiBhZ2dyZWdhdG9yIGludGVyZmFjZS4gU2VlIC4uLy4uLy4uL2V2bS9jb250cmFjdHMvdGVzdHMvTWVhbkFnZ3JlZ2F0b3Iuc29sXG4gICAqICBmb3IgZXhhbXBsZS5cbiAgICovXG5cbiAgLyoqXG4gICAqIEFkZHJlc3Mgb2Ygd2hlcmUgdGhlIGFnZ3JlZ2F0b3IgaW5zdGFuY2UgaXMgaGVsZFxuICAgKlxuICAgKiBAc29sZm9ybWF0IGFkZHJlc3NcbiAgICovXG4gIGFnZ3JlZ2F0b3I6IHN0cmluZ1xuICAvKipcbiAgICogU2VsZWN0b3JzIGZvciB0aGUgaW50ZXJmYWNlIG1ldGhvZHMgbXVzdCBiZSBzcGVjaWZpZWQsIGJlY2F1c2UgdGhlaXJcbiAgICogYXJndW1lbnRzIGNhbiB2YXJ5IGZyb20gYWdncmVnYXRvciB0byBhZ2dyZWdhdG9yLlxuICAgKlxuICAgKiBGdW5jdGlvbiBzZWxlY3RvciBmb3IgYWdncmVnYXRvciBpbml0aWF0ZUpvYiBtZXRob2RcbiAgICpcbiAgICogQHNvbGZvcm1hdCBieXRlczRcbiAgICovXG4gIGFnZ0luaXRpYXRlSm9iU2VsZWN0b3I6IHN0cmluZ1xuICAvKipcbiAgICogRnVuY3Rpb24gc2VsZWN0b3IgZm9yIGFnZ3JlZ2F0b3IgZnVsZmlsbCBtZXRob2RcbiAgICpcbiAgICogQHNvbGZvcm1hdCBieXRlczRcbiAgICovXG4gIGFnZ0Z1bGZpbGxTZWxlY3Rvcjogc3RyaW5nXG59XG5cbi8qKlxuICogQSBjb2xsZWN0aW9uIG9mIG11bHRpcGxlIG9yYWNsZSBzaWduYXR1cmVzIHN0b3JlZCB2aWEgcGFyYWxsZWwgYXJyYXlzXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgT3JhY2xlU2lnbmF0dXJlcyB7XG4gIC8qKlxuICAgKiBUaGUgcmVjb3ZlcnkgcGFyYW1ldGVycyBub3JtYWxpemVkIGZvciBTb2xpZGl0eSwgZWl0aGVyIDI3IG9yIDI4XG4gICAqXG4gICAqIEBzb2xmb3JtYXQgdWludDhbXVxuICAgKi9cbiAgdnM6IGV0aGVycy51dGlscy5CaWdOdW1iZXJpc2hbXVxuICAvKipcbiAgICogdGhlIHIgY29vcmRpbmF0ZSB3aXRoaW4gKHIsIHMpIHB1YmxpYyBwb2ludCBvZiBhIHNpZ25hdHVyZVxuICAgKlxuICAgKiBAc29sZm9ybWF0IGJ5dGVzMzJbXVxuICAgKi9cbiAgcnM6IHN0cmluZ1tdXG4gIC8qKlxuICAgKiB0aGUgcyBjb29yZGluYXRlIHdpdGhpbiAociwgcykgcHVibGljIHBvaW50IG9mIGEgc2lnbmF0dXJlXG4gICAqXG4gICAqIEBzb2xmb3JtYXQgIGJ5dGVzMzJbXVxuICAgKi9cbiAgc3M6IHN0cmluZ1tdXG59XG5cbi8qKlxuICogQ3JlYXRlIGEgc2VydmljZSBhZ3JlZW1lbnQgd2l0aCBzYW5lIHRlc3RpbmcgZGVmYXVsdHNcbiAqXG4gKiBAcGFyYW0gb3ZlcnJpZGVzIFZhbHVlcyB0byBvdmVycmlkZSBzZXJ2aWNlIGFncmVlbWVudCBkZWZhdWx0c1xuICovXG5leHBvcnQgZnVuY3Rpb24gc2VydmljZUFncmVlbWVudChcbiAgb3ZlcnJpZGVzOiBQYXJ0aWFsPFNlcnZpY2VBZ3JlZW1lbnQ+LFxuKTogU2VydmljZUFncmVlbWVudCB7XG4gIGNvbnN0IGFncmVlbWVudDogU2VydmljZUFncmVlbWVudCA9IHtcbiAgICBwYXltZW50OiBiaWdOdW0oJzEwMDAwMDAwMDAwMDAwMDAwMDAnKSxcbiAgICBleHBpcmF0aW9uOiBiaWdOdW0oMzAwKSxcbiAgICBlbmRBdDogc2l4TW9udGhzRnJvbU5vdygpLFxuICAgIG9yYWNsZXM6IFtdLFxuICAgIHJlcXVlc3REaWdlc3Q6XG4gICAgICAnMHhiYWRjMGRlNWJhZGMwZGU1YmFkYzBkZTViYWRjMGRlNWJhZGMwZGU1YmFkYzBkZTViYWRjMGRlNWJhZGMwZGU1JyxcbiAgICBhZ2dyZWdhdG9yOiAnMHgzMTQxNTkyNjUzNTg5NzkzMjM4NDYyNjQzMzgzMjc5NTAyODg0MTk3JyxcbiAgICBhZ2dJbml0aWF0ZUpvYlNlbGVjdG9yOiAnMHhkNDNhMTJmNicsXG4gICAgYWdnRnVsZmlsbFNlbGVjdG9yOiAnMHg5NzYwMTY4ZicsXG4gICAgLi4ub3ZlcnJpZGVzLFxuICB9XG5cbiAgcmV0dXJuIGFncmVlbWVudFxufVxuXG4vKipcbiAqIENoZWNrIHRoYXQgYWxsIHZhbHVlcyBmb3IgdGhlIHN0cnVjdCBhdCB0aGlzIFNBSUQgaGF2ZSBkZWZhdWx0IHZhbHVlcy5cbiAqXG4gKiBGb3IgZXhhbXBsZSwgd2hlbiBhbiBpbnZhbGlkIHNlcnZpY2UgYWdyZWVtZW50IGluaXRpYWxpemF0aW9uIHJlcXVlc3QgaXMgbWFkZSB0byBhIGBDb29yZGluYXRvcmAsIHdlIHdhbnQgdG8gbWFrZSBzdXJlIHRoYXRcbiAqIGl0IGRpZCBub3QgaW5pdGlhbGl6ZSBpdHMgc2VydmljZSBhZ3JlZW1lbnQgc3RydWN0IHRvIGFueSB2YWx1ZSwgaGVuY2UgY2hlY2tpbmcgZm9yIGl0IGJlaW5nIGVtcHR5LlxuICpcbiAqIEBwYXJhbSBjb29yZGluYXRvciBUaGUgY29vcmRpbmF0b3IgY29udHJhY3RcbiAqIEBwYXJhbSBzZXJ2aWNlQWdyZWVtZW50SUQgVGhlIHNlcnZpY2UgYWdyZWVtZW50IElEXG4gKlxuICogQHRocm93cyB3aGVuIGFueSBvZiBwYXltZW50LCBleHBpcmF0aW9uLCBlbmRBdCwgcmVxdWVzdERpZ2VzdCBhcmUgbm9uLWVtcHR5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRTZXJ2aWNlQWdyZWVtZW50RW1wdHkoXG4gIHNhOiBPbWl0PFNlcnZpY2VBZ3JlZW1lbnQsICdvcmFjbGVzJz4sXG4pIHtcbiAgbWF0Y2hlcnMuYmlnTnVtKHNhLnBheW1lbnQsIGJpZ051bSgwKSwgJ3NlcnZpY2UgYWdyZWVtZW50IGlzIG5vdCBhYnNlbnQnKVxuICBtYXRjaGVycy5iaWdOdW0oc2EuZXhwaXJhdGlvbiwgYmlnTnVtKDApLCAnc2VydmljZSBhZ3JlZW1lbnQgaXMgbm90IGFic2VudCcpXG4gIG1hdGNoZXJzLmJpZ051bShzYS5lbmRBdCwgYmlnTnVtKDApLCAnc2VydmljZSBhZ3JlZW1lbnQgaXMgbm90IGFic2VudCcpXG4gIGFzc2VydC5lcXVhbChcbiAgICBzYS5yZXF1ZXN0RGlnZXN0LFxuICAgICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICApXG59XG5cbi8qKlxuICogQ3JlYXRlIHBhcmFtZXRlcnMgbmVlZGVkIGZvciB0aGVcbiAqIGBgYHNvbGlkaXR5XG4gKiAgIGZ1bmN0aW9uIGluaXRpYXRlU2VydmljZUFncmVlbWVudChcbiAqICAgIGJ5dGVzIG1lbW9yeSBfc2VydmljZUFncmVlbWVudERhdGEsXG4gKiAgICBieXRlcyBtZW1vcnkgX29yYWNsZVNpZ25hdHVyZXNEYXRhXG4gKiAgKVxuICogYGBgXG4gKiBtZXRob2Qgb2YgdGhlIGBDb29yZGluYXRvci5zb2xgIGNvbnRyYWN0XG4gKlxuICogQHBhcmFtIG92ZXJyaWRlcyBWYWx1ZXMgdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHRzIGZvciBjcmVhdGluZyBhIHNlcnZpY2UgYWdyZWVtZW50XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBpbml0aWF0ZVNBUGFyYW1zKFxuICBvdmVycmlkZXM6IFBhcnRpYWw8U2VydmljZUFncmVlbWVudD4sXG4pOiBQcm9taXNlPFtzdHJpbmcsIHN0cmluZ10+IHtcbiAgY29uc3Qgc2EgPSBzZXJ2aWNlQWdyZWVtZW50KG92ZXJyaWRlcylcbiAgY29uc3Qgc2lnbmF0dXJlcyA9IGF3YWl0IGdlbmVyYXRlT3JhY2xlU2lnbmF0dXJlcyhzYSlcblxuICByZXR1cm4gW2VuY29kZVNlcnZpY2VBZ3JlZW1lbnQoc2EpLCBlbmNvZGVPcmFjbGVTaWduYXR1cmVzKHNpZ25hdHVyZXMpXVxufVxuXG5jb25zdCBTRVJWSUNFX0FHUkVFTUVOVF9UWVBFUyA9IFtcbiAgJ3VpbnQyNTYnLFxuICAndWludDI1NicsXG4gICd1aW50MjU2JyxcbiAgJ2FkZHJlc3NbXScsXG4gICdieXRlczMyJyxcbiAgJ2FkZHJlc3MnLFxuICAnYnl0ZXM0JyxcbiAgJ2J5dGVzNCcsXG5dXG5cbi8qKlxuICogQUJJIGVuY29kZSBhIHNlcnZpY2UgYWdyZWVtZW50IG9iamVjdFxuICpcbiAqIEBwYXJhbSBzYSBUaGUgc2VydmljZSBhZ3JlZW1lbnQgdG8gZW5jb2RlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbmNvZGVTZXJ2aWNlQWdyZWVtZW50KHNhOiBTZXJ2aWNlQWdyZWVtZW50KSB7XG4gIHJldHVybiBldGhlcnMudXRpbHMuZGVmYXVsdEFiaUNvZGVyLmVuY29kZShcbiAgICBTRVJWSUNFX0FHUkVFTUVOVF9UWVBFUyxcbiAgICBzZXJ2aWNlQWdyZWVtZW50VmFsdWVzKHNhKSxcbiAgKVxufVxuXG4vKipcbiAqIEdlbmVyYXRlIHRoZSB1bmlxdWUgaWRlbnRpZmllciBvZiBhIHNlcnZpY2UgYWdyZWVtZW50IGJ5IGNvbXB1dGluZyBpdHNcbiAqIGRpZ2VzdC5cbiAqXG4gKiBAcGFyYW0gc2EgVGhlIHNlcnZpY2UgYWdyZWVtZW50IHRvIGNvbXB1dGUgdGhlIGRpZ2VzdCBvZlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVTQUlEKFxuICBzYTogU2VydmljZUFncmVlbWVudCxcbik6IFJldHVyblR5cGU8dHlwZW9mIGV0aGVycy51dGlscy5rZWNjYWsyNTY+IHtcbiAgcmV0dXJuIGV0aGVycy51dGlscy5zb2xpZGl0eUtlY2NhazI1NihcbiAgICBTRVJWSUNFX0FHUkVFTUVOVF9UWVBFUyxcbiAgICBzZXJ2aWNlQWdyZWVtZW50VmFsdWVzKHNhKSxcbiAgKVxufVxuXG4vKipcbiAqIEFCSSBlbmNvZGUgdGhlIGphdmFzY3JpcHQgcmVwcmVzZW50YXRpb24gb2YgT3JhY2xlU2lnbmF0dXJlc1xuICpgYGBzb2xpZGl0eVxuICogIHN0cnVjdCBPcmFjbGVTaWduYXR1cmVzIHtcbiAqICAgIHVpbnQ4W10gdnM7XG4gKiAgICBieXRlczMyW10gcnM7XG4gKiAgICBieXRlczMyW10gc3M7XG4gKiAgfVxuICogYGBgXG4gKlxuICogQHBhcmFtIG9zIFRoZSBvcmFjbGUgc2lnbmF0dXJlcyB0byBBQkkgZW5jb2RlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbmNvZGVPcmFjbGVTaWduYXR1cmVzKG9zOiBPcmFjbGVTaWduYXR1cmVzKSB7XG4gIGNvbnN0IE9SQUNMRV9TSUdOQVRVUkVTX1RZUEVTID0gWyd1aW50OFtdJywgJ2J5dGVzMzJbXScsICdieXRlczMyW10nXVxuICBjb25zdCBvc1ZhbHVlcyA9IFtvcy52cywgb3MucnMsIG9zLnNzXVxuXG4gIHJldHVybiBldGhlcnMudXRpbHMuZGVmYXVsdEFiaUNvZGVyLmVuY29kZShPUkFDTEVfU0lHTkFUVVJFU19UWVBFUywgb3NWYWx1ZXMpXG59XG5cbi8qKlxuICogQWJpIGVuY29kZSB0aGUgb3JhY2xlUmVxdWVzdCgpIG1ldGhvZCBmb3IgYENvb3JkaW5hdG9yLnNvbGBcbiAqIGBgYHNvbGlkaXR5XG4gKiAgZnVuY3Rpb24gb3JhY2xlUmVxdWVzdChcbiAqICAgIGFkZHJlc3MgX3NlbmRlcixcbiAqICAgIHVpbnQyNTYgX2Ftb3VudCxcbiAqICAgIGJ5dGVzMzIgX3NBSWQsXG4gKiAgICBhZGRyZXNzIF9jYWxsYmFja0FkZHJlc3MsXG4gKiAgICBieXRlczQgX2NhbGxiYWNrRnVuY3Rpb25JZCxcbiAqICAgIHVpbnQyNTYgX25vbmNlLFxuICogICAgdWludDI1NiBfZGF0YVZlcnNpb24sXG4gKiAgICBieXRlcyBjYWxsZGF0YSBfZGF0YVxuICogIClcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBzQUlEIFRoZSBzZXJ2aWNlIGFncmVlbWVudCBJRFxuICogQHBhcmFtIGNhbGxiYWNrQWRkciBUaGUgY2FsbGJhY2sgY29udHJhY3QgYWRkcmVzcyBmb3IgdGhlIHJlc3BvbnNlXG4gKiBAcGFyYW0gY2FsbGJhY2tGdW5jdGlvbklkIFRoZSBjYWxsYmFjayBmdW5jdGlvbiBpZCBmb3IgdGhlIHJlc3BvbnNlXG4gKiBAcGFyYW0gbm9uY2UgVGhlIG5vbmNlIHNlbnQgYnkgdGhlIHJlcXVlc3RlclxuICogQHBhcmFtIGRhdGEgVGhlIENCT1IgcGF5bG9hZCBvZiB0aGUgcmVxdWVzdFxuICovXG5leHBvcnQgZnVuY3Rpb24gZW5jb2RlT3JhY2xlUmVxdWVzdChcbiAgc3BlY0lkOiBzdHJpbmcsXG4gIHRvOiBzdHJpbmcsXG4gIGZIYXNoOiBzdHJpbmcsXG4gIG5vbmNlOiBCaWdOdW1iZXJpc2gsXG4gIGRhdGFCeXRlczogc3RyaW5nLFxuKTogc3RyaW5nIHtcbiAgY29uc3Qgb3JhY2xlUmVxdWVzdFNpZ2hhc2ggPSAnMHg0MDQyOTk0NidcbiAgY29uc3Qgb3JhY2xlUmVxdWVzdElucHV0cyA9IFtcbiAgICB7IG5hbWU6ICdfc2VuZGVyJywgdHlwZTogJ2FkZHJlc3MnIH0sXG4gICAgeyBuYW1lOiAnX2Ftb3VudCcsIHR5cGU6ICd1aW50MjU2JyB9LFxuICAgIHsgbmFtZTogJ19zQUlkJywgdHlwZTogJ2J5dGVzMzInIH0sXG4gICAgeyBuYW1lOiAnX2NhbGxiYWNrQWRkcmVzcycsIHR5cGU6ICdhZGRyZXNzJyB9LFxuICAgIHsgbmFtZTogJ19jYWxsYmFja0Z1bmN0aW9uSWQnLCB0eXBlOiAnYnl0ZXM0JyB9LFxuICAgIHsgbmFtZTogJ19ub25jZScsIHR5cGU6ICd1aW50MjU2JyB9LFxuICAgIHsgbmFtZTogJ19kYXRhVmVyc2lvbicsIHR5cGU6ICd1aW50MjU2JyB9LFxuICAgIHsgbmFtZTogJ19kYXRhJywgdHlwZTogJ2J5dGVzJyB9LFxuICBdXG5cbiAgY29uc3QgZW5jb2RlZFBhcmFtcyA9IGV0aGVycy51dGlscy5kZWZhdWx0QWJpQ29kZXIuZW5jb2RlKFxuICAgIG9yYWNsZVJlcXVlc3RJbnB1dHMubWFwKChpKSA9PiBpLnR5cGUpLFxuICAgIFtldGhlcnMuY29uc3RhbnRzLkFkZHJlc3NaZXJvLCAwLCBzcGVjSWQsIHRvLCBmSGFzaCwgbm9uY2UsIDEsIGRhdGFCeXRlc10sXG4gIClcblxuICByZXR1cm4gYCR7b3JhY2xlUmVxdWVzdFNpZ2hhc2h9JHtzdHJpcEhleFByZWZpeChlbmNvZGVkUGFyYW1zKX1gXG59XG5cbi8qKlxuICogR2VuZXJhdGVzIHRoZSBvcmFjbGUgc2lnbmF0dXJlcyBvbiBhIFNlcnZpY2VBZ3JlZW1lbnRcbiAqXG4gKiBAcGFyYW0gc2VydmljZUFncmVlbWVudCBUaGUgc2VydmljZSBhZ3JlZW1lbnQgdG8gc2lnblxuICogQHBhcmFtIHNpZ25lcnMgVGhlIGxpc3Qgb3JhY2xlcyB0aGF0IHdpbGwgc2lnbiB0aGUgc2VydmljZSBhZ3JlZW1lbnRcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdlbmVyYXRlT3JhY2xlU2lnbmF0dXJlcyhcbiAgc2VydmljZUFncmVlbWVudDogU2VydmljZUFncmVlbWVudCxcbik6IFByb21pc2U8T3JhY2xlU2lnbmF0dXJlcz4ge1xuICBjb25zdCBzQUlEID0gZ2VuZXJhdGVTQUlEKHNlcnZpY2VBZ3JlZW1lbnQpXG4gIGNvbnN0IHNpZ25hdHVyZXMgPSBbXVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc2VydmljZUFncmVlbWVudC5vcmFjbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgb3JhY2xlID0gc2VydmljZUFncmVlbWVudC5vcmFjbGVzW2ldXG4gICAgaWYgKCEob3JhY2xlIGluc3RhbmNlb2YgZXRoZXJzLldhbGxldCkpIHtcbiAgICAgIHRocm93IEVycm9yKCdjYW5ub3QgZ2VuZXJhdGUgc2lnbmF0dXJlcyB3aXRob3V0IG9yYWNsZSB3YWxsZXRzJylcbiAgICB9XG4gICAgY29uc3Qgb3JhY2xlU2lnbmF0dXJlID0gYXdhaXQgcGVyc29uYWxTaWduKHNBSUQsIG9yYWNsZSlcbiAgICBjb25zdCByZXF1ZXN0RGlnZXN0QWRkciA9IHJlY292ZXJBZGRyZXNzRnJvbVNpZ25hdHVyZShzQUlELCBvcmFjbGVTaWduYXR1cmUpXG4gICAgYXNzZXJ0LmVxdWFsKG9yYWNsZS5hZGRyZXNzLCByZXF1ZXN0RGlnZXN0QWRkcilcbiAgICBzaWduYXR1cmVzLnB1c2gob3JhY2xlU2lnbmF0dXJlKVxuICB9XG5cbiAgcmV0dXJuIGNvbWJpbmVPcmFjbGVTaWduYXR1cmVzKHNpZ25hdHVyZXMpXG59XG5cbi8qKlxuICogU2lnbnMgYSBtZXNzYWdlIGFjY29yZGluZyB0byBldGhlcmV1bSBzcGVjcyBieSBmaXJzdCBhcHBlbmRpbmdcbiAqIFwiXFx4MTlFdGhlcmV1bSBTaWduZWQgTWVzc2FnZTpcXG4nICsgPG1lc3NhZ2UubGVuZ3RoPlwiIHRvIHRoZSBtZXNzYWdlXG4gKlxuICogQHBhcmFtIG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gc2lnbiAtIGVpdGhlciBhIEJ1ZmZlciBvciBhIGhleCBzdHJpbmdcbiAqIEBwYXJhbSB3YWxsZXQgVGhlIHdhbGxldCBvZiB0aGUgc2lnbmVyXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwZXJzb25hbFNpZ24oXG4gIG1lc3NhZ2U6IEJ1ZmZlciB8IHN0cmluZyxcbiAgd2FsbGV0OiBldGhlcnMuV2FsbGV0LFxuKTogUHJvbWlzZTxSZXF1aXJlZDx1dGlscy5TaWduYXR1cmU+PiB7XG4gIGlmIChtZXNzYWdlIGluc3RhbmNlb2YgU3RyaW5nICYmICF1dGlscy5pc0hleFN0cmluZyhtZXNzYWdlKSkge1xuICAgIHRocm93IEVycm9yKGBUaGUgbWVzc2FnZSAke21lc3NhZ2V9IGlzIG5vdCBhIHZhbGlkIGhleCBzdHJpbmdgKVxuICB9XG5cbiAgY29uc3QgZmxhdFNpZyA9IGF3YWl0IHdhbGxldC5zaWduTWVzc2FnZSh1dGlscy5hcnJheWlmeShtZXNzYWdlKSlcbiAgY29uc3Qgc3BsaXRTaWduYXR1cmUgPSB1dGlscy5zcGxpdFNpZ25hdHVyZShmbGF0U2lnKVxuXG4gIGZ1bmN0aW9uIGFzc2VydElzU2lnbmF0dXJlKFxuICAgIHNpZzogdXRpbHMuU2lnbmF0dXJlLFxuICApOiBhc3NlcnRzIHNpZyBpcyBSZXF1aXJlZDx1dGlscy5TaWduYXR1cmU+IHtcbiAgICBpZiAoIXNpZy52KSB0aHJvdyBFcnJvcihgQ291bGQgbm90IGV4dHJhY3QgdiBmcm9tIHNpZ25hdHVyZWApXG4gIH1cbiAgYXNzZXJ0SXNTaWduYXR1cmUoc3BsaXRTaWduYXR1cmUpXG5cbiAgcmV0dXJuIHNwbGl0U2lnbmF0dXJlXG59XG5cbi8qKlxuICogUmVjb3ZlcnMgdGhlIGFkZHJlc3Mgb2YgdGhlIHNpZ25lciBvZiBhIG1lc3NhZ2VcbiAqXG4gKiBAcGFyYW0gbWVzc2FnZSBUaGUgbWVzc2FnZSB0aGF0IHdhcyBzaWduZWRcbiAqIEBwYXJhbSBzaWduYXR1cmUgVGhlIHNpZ25hdHVyZSBvbiB0aGUgbWVzc2FnZVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVjb3ZlckFkZHJlc3NGcm9tU2lnbmF0dXJlKFxuICBtZXNzYWdlOiBzdHJpbmcgfCBCdWZmZXIsXG4gIHNpZ25hdHVyZTogUmVxdWlyZWQ8dXRpbHMuU2lnbmF0dXJlPixcbik6IHN0cmluZyB7XG4gIGNvbnN0IG1lc3NhZ2VCdWZmID0gdXRpbHMuYXJyYXlpZnkobWVzc2FnZSlcbiAgcmV0dXJuIHV0aWxzLnZlcmlmeU1lc3NhZ2UobWVzc2FnZUJ1ZmYsIHNpZ25hdHVyZSlcbn1cblxuLyoqXG4gKiBDb21iaW5lIHYsIHIsIGFuZCBzIHBhcmFtcyBvZiBtdWx0aXBsZSBzaWduYXR1cmVzIGludG8gZm9ybWF0IGV4cGVjdGVkIGJ5IGNvbnRyYWN0c1xuICpcbiAqIEBwYXJhbSBzaWduYXR1cmVzIFRoZSBsaXN0IG9mIHNpZ25hdHVyZXMgdG8gY29tYmluZVxuICovXG5leHBvcnQgZnVuY3Rpb24gY29tYmluZU9yYWNsZVNpZ25hdHVyZXMoXG4gIHNpZ25hdHVyZXM6IFJlcXVpcmVkPHV0aWxzLlNpZ25hdHVyZT5bXSxcbik6IE9yYWNsZVNpZ25hdHVyZXMge1xuICByZXR1cm4gc2lnbmF0dXJlcy5yZWR1Y2U8T3JhY2xlU2lnbmF0dXJlcz4oXG4gICAgKHByZXYsIHsgdiwgciwgcyB9KSA9PiB7XG4gICAgICBwcmV2LnZzLnB1c2godilcbiAgICAgIHByZXYucnMucHVzaChyKVxuICAgICAgcHJldi5zcy5wdXNoKHMpXG5cbiAgICAgIHJldHVybiBwcmV2XG4gICAgfSxcbiAgICB7IHZzOiBbXSwgcnM6IFtdLCBzczogW10gfSxcbiAgKVxufVxuXG5mdW5jdGlvbiBzZXJ2aWNlQWdyZWVtZW50VmFsdWVzKHNhOiBTZXJ2aWNlQWdyZWVtZW50KSB7XG4gIHJldHVybiBbXG4gICAgc2EucGF5bWVudCxcbiAgICBzYS5leHBpcmF0aW9uLFxuICAgIHNhLmVuZEF0LFxuICAgIHNhLm9yYWNsZXMubWFwKChvKSA9PiAobyBpbnN0YW5jZW9mIGV0aGVycy5XYWxsZXQgPyBvLmFkZHJlc3MgOiBvKSksXG4gICAgc2EucmVxdWVzdERpZ2VzdCxcbiAgICBzYS5hZ2dyZWdhdG9yLFxuICAgIHNhLmFnZ0luaXRpYXRlSm9iU2VsZWN0b3IsXG4gICAgc2EuYWdnRnVsZmlsbFNlbGVjdG9yLFxuICBdXG59XG4iXX0=