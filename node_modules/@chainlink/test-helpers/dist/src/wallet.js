"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.fundWallet = exports.createWallet = exports.createFundedWallet = void 0;
/**
 * @packageDocumentation
 *
 * This file contains functionality for ease of creating ethereum account abstractions
 * based on ethers.js. Useful for creating many accounts for testing purposes only.
 */
const ethers_1 = require("ethers");
const debug_1 = require("./debug");
const helpers_1 = require("./helpers");
/**
 * Create a pre-funded wallet with all defaults
 *
 * @param provider The provider to connect to the created wallet and to withdraw funds from
 * @param accountIndex The account index of the corresponding wallet derivation path
 */
async function createFundedWallet(provider, accountIndex) {
    const wallet = createWallet(provider, accountIndex);
    const receipt = await fundWallet(wallet, provider);
    return { wallet, receipt };
}
exports.createFundedWallet = createFundedWallet;
/**
 * Create an ethers.js wallet instance that is connected to the given provider
 *
 * @param provider A compatible ethers.js provider such as the one returned by `ganache.provider()` to connect the wallet to
 * @param accountIndex The account index to derive from the mnemonic phrase
 */
function createWallet(provider, accountIndex) {
    const debug = debug_1.makeDebug('wallet:createWallet');
    if (accountIndex < 0) {
        throw Error(`Account index must be greater than 0, got ${accountIndex}`);
    }
    /**
     * THIS IS FOR TESTING PURPOSES ONLY
     */
    const mnemonicPhrase = 'dose weasel clever culture letter volume endorse used harvest ripple circle install';
    const path = `m/44'/60'/${accountIndex}'/0/0`;
    debug('created wallet with parameters: %o', { mnemonicPhrase, path });
    return ethers_1.ethers.Wallet.fromMnemonic(mnemonicPhrase, path).connect(provider);
}
exports.createWallet = createWallet;
/**
 * Fund a wallet with unlocked accounts available from the given provider
 *
 * @param wallet The ethers wallet to fund
 * @param provider The provider which has control over unlocked, funded accounts to transfer funds from
 * @param overrides Transaction parameters to override when sending the funding transaction
 */
async function fundWallet(wallet, provider, overrides) {
    const debug = debug_1.makeDebug('wallet:fundWallet');
    // OVM has no native ETH/value, so wallet funding is not supported
    if (helpers_1.isOVM())
        return;
    debug('funding wallet');
    debug('retreiving accounts...');
    const nodeOwnedAccounts = await provider.listAccounts();
    debug('retreived accounts: %o', nodeOwnedAccounts);
    const signer = provider.getSigner(nodeOwnedAccounts[0]);
    const txParams = {
        to: wallet.address,
        value: ethers_1.ethers.utils.parseEther('10'),
        ...overrides,
    };
    debug('sending tx with the following parameters: %o', txParams);
    const tx = await signer.sendTransaction(txParams);
    debug('waiting on tx %s to complete...', tx.hash);
    const receipt = await tx.wait();
    debug('tx %s confirmed with tx receipt %o', tx.hash, receipt);
    return receipt;
}
exports.fundWallet = fundWallet;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2FsbGV0LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL3dhbGxldC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQTs7Ozs7R0FLRztBQUNILG1DQUErQjtBQUUvQixtQ0FBbUM7QUFDbkMsdUNBQWlDO0FBWWpDOzs7OztHQUtHO0FBQ0ksS0FBSyxVQUFVLGtCQUFrQixDQUN0QyxRQUF5QixFQUN6QixZQUFvQjtJQUVwQixNQUFNLE1BQU0sR0FBRyxZQUFZLENBQUMsUUFBUSxFQUFFLFlBQVksQ0FBQyxDQUFBO0lBQ25ELE1BQU0sT0FBTyxHQUFHLE1BQU0sVUFBVSxDQUFDLE1BQU0sRUFBRSxRQUFRLENBQUMsQ0FBQTtJQUNsRCxPQUFPLEVBQUUsTUFBTSxFQUFFLE9BQU8sRUFBRSxDQUFBO0FBQzVCLENBQUM7QUFQRCxnREFPQztBQUVEOzs7OztHQUtHO0FBQ0gsU0FBZ0IsWUFBWSxDQUMxQixRQUEwQyxFQUMxQyxZQUFvQjtJQUVwQixNQUFNLEtBQUssR0FBRyxpQkFBUyxDQUFDLHFCQUFxQixDQUFDLENBQUE7SUFDOUMsSUFBSSxZQUFZLEdBQUcsQ0FBQyxFQUFFO1FBQ3BCLE1BQU0sS0FBSyxDQUFDLDZDQUE2QyxZQUFZLEVBQUUsQ0FBQyxDQUFBO0tBQ3pFO0lBRUQ7O09BRUc7SUFDSCxNQUFNLGNBQWMsR0FDbEIscUZBQXFGLENBQUE7SUFFdkYsTUFBTSxJQUFJLEdBQUcsYUFBYSxZQUFZLE9BQU8sQ0FBQTtJQUM3QyxLQUFLLENBQUMsb0NBQW9DLEVBQUUsRUFBRSxjQUFjLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQTtJQUVyRSxPQUFPLGVBQU0sQ0FBQyxNQUFNLENBQUMsWUFBWSxDQUFDLGNBQWMsRUFBRSxJQUFJLENBQUMsQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUE7QUFDM0UsQ0FBQztBQW5CRCxvQ0FtQkM7QUFFRDs7Ozs7O0dBTUc7QUFDSSxLQUFLLFVBQVUsVUFBVSxDQUM5QixNQUFxQixFQUNyQixRQUEwQyxFQUMxQyxTQUFvRTtJQUVwRSxNQUFNLEtBQUssR0FBRyxpQkFBUyxDQUFDLG1CQUFtQixDQUFDLENBQUE7SUFFNUMsa0VBQWtFO0lBQ2xFLElBQUksZUFBSyxFQUFFO1FBQUUsT0FBTTtJQUVuQixLQUFLLENBQUMsZ0JBQWdCLENBQUMsQ0FBQTtJQUV2QixLQUFLLENBQUMsd0JBQXdCLENBQUMsQ0FBQTtJQUUvQixNQUFNLGlCQUFpQixHQUFHLE1BQU0sUUFBUSxDQUFDLFlBQVksRUFBRSxDQUFBO0lBQ3ZELEtBQUssQ0FBQyx3QkFBd0IsRUFBRSxpQkFBaUIsQ0FBQyxDQUFBO0lBRWxELE1BQU0sTUFBTSxHQUFHLFFBQVEsQ0FBQyxTQUFTLENBQUMsaUJBQWlCLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQTtJQUV2RCxNQUFNLFFBQVEsR0FBd0M7UUFDcEQsRUFBRSxFQUFFLE1BQU0sQ0FBQyxPQUFPO1FBQ2xCLEtBQUssRUFBRSxlQUFNLENBQUMsS0FBSyxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUM7UUFDcEMsR0FBRyxTQUFTO0tBQ2IsQ0FBQTtJQUNELEtBQUssQ0FBQyw4Q0FBOEMsRUFBRSxRQUFRLENBQUMsQ0FBQTtJQUMvRCxNQUFNLEVBQUUsR0FBRyxNQUFNLE1BQU0sQ0FBQyxlQUFlLENBQUMsUUFBUSxDQUFDLENBQUE7SUFFakQsS0FBSyxDQUFDLGlDQUFpQyxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQTtJQUNqRCxNQUFNLE9BQU8sR0FBRyxNQUFNLEVBQUUsQ0FBQyxJQUFJLEVBQUUsQ0FBQTtJQUMvQixLQUFLLENBQUMsb0NBQW9DLEVBQUUsRUFBRSxDQUFDLElBQUksRUFBRSxPQUFPLENBQUMsQ0FBQTtJQUM3RCxPQUFPLE9BQU8sQ0FBQTtBQUNoQixDQUFDO0FBL0JELGdDQStCQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQHBhY2thZ2VEb2N1bWVudGF0aW9uXG4gKlxuICogVGhpcyBmaWxlIGNvbnRhaW5zIGZ1bmN0aW9uYWxpdHkgZm9yIGVhc2Ugb2YgY3JlYXRpbmcgZXRoZXJldW0gYWNjb3VudCBhYnN0cmFjdGlvbnNcbiAqIGJhc2VkIG9uIGV0aGVycy5qcy4gVXNlZnVsIGZvciBjcmVhdGluZyBtYW55IGFjY291bnRzIGZvciB0ZXN0aW5nIHB1cnBvc2VzIG9ubHkuXG4gKi9cbmltcG9ydCB7IGV0aGVycyB9IGZyb20gJ2V0aGVycydcbmltcG9ydCB7IEpzb25ScGNQcm92aWRlciB9IGZyb20gJ2V0aGVycy9wcm92aWRlcnMnXG5pbXBvcnQgeyBtYWtlRGVidWcgfSBmcm9tICcuL2RlYnVnJ1xuaW1wb3J0IHsgaXNPVk0gfSBmcm9tICcuL2hlbHBlcnMnXG5cbmludGVyZmFjZSBSQ3JlYXRlRnVuZGVkV2FsbGV0IHtcbiAgLyoqXG4gICAqIFRoZSBjcmVhdGVkIHdhbGxldFxuICAgKi9cbiAgd2FsbGV0OiBldGhlcnMuV2FsbGV0XG4gIC8qKlxuICAgKiBUaGUgcmVjZWlwdCBvZiB0aGUgdHggdGhhdCBmdW5kZWQgdGhlIGNyZWF0ZWQgd2FsbGV0XG4gICAqL1xuICByZWNlaXB0PzogZXRoZXJzLnByb3ZpZGVycy5UcmFuc2FjdGlvblJlY2VpcHRcbn1cbi8qKlxuICogQ3JlYXRlIGEgcHJlLWZ1bmRlZCB3YWxsZXQgd2l0aCBhbGwgZGVmYXVsdHNcbiAqXG4gKiBAcGFyYW0gcHJvdmlkZXIgVGhlIHByb3ZpZGVyIHRvIGNvbm5lY3QgdG8gdGhlIGNyZWF0ZWQgd2FsbGV0IGFuZCB0byB3aXRoZHJhdyBmdW5kcyBmcm9tXG4gKiBAcGFyYW0gYWNjb3VudEluZGV4IFRoZSBhY2NvdW50IGluZGV4IG9mIHRoZSBjb3JyZXNwb25kaW5nIHdhbGxldCBkZXJpdmF0aW9uIHBhdGhcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZUZ1bmRlZFdhbGxldChcbiAgcHJvdmlkZXI6IEpzb25ScGNQcm92aWRlcixcbiAgYWNjb3VudEluZGV4OiBudW1iZXIsXG4pOiBQcm9taXNlPFJDcmVhdGVGdW5kZWRXYWxsZXQ+IHtcbiAgY29uc3Qgd2FsbGV0ID0gY3JlYXRlV2FsbGV0KHByb3ZpZGVyLCBhY2NvdW50SW5kZXgpXG4gIGNvbnN0IHJlY2VpcHQgPSBhd2FpdCBmdW5kV2FsbGV0KHdhbGxldCwgcHJvdmlkZXIpXG4gIHJldHVybiB7IHdhbGxldCwgcmVjZWlwdCB9XG59XG5cbi8qKlxuICogQ3JlYXRlIGFuIGV0aGVycy5qcyB3YWxsZXQgaW5zdGFuY2UgdGhhdCBpcyBjb25uZWN0ZWQgdG8gdGhlIGdpdmVuIHByb3ZpZGVyXG4gKlxuICogQHBhcmFtIHByb3ZpZGVyIEEgY29tcGF0aWJsZSBldGhlcnMuanMgcHJvdmlkZXIgc3VjaCBhcyB0aGUgb25lIHJldHVybmVkIGJ5IGBnYW5hY2hlLnByb3ZpZGVyKClgIHRvIGNvbm5lY3QgdGhlIHdhbGxldCB0b1xuICogQHBhcmFtIGFjY291bnRJbmRleCBUaGUgYWNjb3VudCBpbmRleCB0byBkZXJpdmUgZnJvbSB0aGUgbW5lbW9uaWMgcGhyYXNlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVXYWxsZXQoXG4gIHByb3ZpZGVyOiBldGhlcnMucHJvdmlkZXJzLkpzb25ScGNQcm92aWRlcixcbiAgYWNjb3VudEluZGV4OiBudW1iZXIsXG4pOiBldGhlcnMuV2FsbGV0IHtcbiAgY29uc3QgZGVidWcgPSBtYWtlRGVidWcoJ3dhbGxldDpjcmVhdGVXYWxsZXQnKVxuICBpZiAoYWNjb3VudEluZGV4IDwgMCkge1xuICAgIHRocm93IEVycm9yKGBBY2NvdW50IGluZGV4IG11c3QgYmUgZ3JlYXRlciB0aGFuIDAsIGdvdCAke2FjY291bnRJbmRleH1gKVxuICB9XG5cbiAgLyoqXG4gICAqIFRISVMgSVMgRk9SIFRFU1RJTkcgUFVSUE9TRVMgT05MWVxuICAgKi9cbiAgY29uc3QgbW5lbW9uaWNQaHJhc2UgPVxuICAgICdkb3NlIHdlYXNlbCBjbGV2ZXIgY3VsdHVyZSBsZXR0ZXIgdm9sdW1lIGVuZG9yc2UgdXNlZCBoYXJ2ZXN0IHJpcHBsZSBjaXJjbGUgaW5zdGFsbCdcblxuICBjb25zdCBwYXRoID0gYG0vNDQnLzYwJy8ke2FjY291bnRJbmRleH0nLzAvMGBcbiAgZGVidWcoJ2NyZWF0ZWQgd2FsbGV0IHdpdGggcGFyYW1ldGVyczogJW8nLCB7IG1uZW1vbmljUGhyYXNlLCBwYXRoIH0pXG5cbiAgcmV0dXJuIGV0aGVycy5XYWxsZXQuZnJvbU1uZW1vbmljKG1uZW1vbmljUGhyYXNlLCBwYXRoKS5jb25uZWN0KHByb3ZpZGVyKVxufVxuXG4vKipcbiAqIEZ1bmQgYSB3YWxsZXQgd2l0aCB1bmxvY2tlZCBhY2NvdW50cyBhdmFpbGFibGUgZnJvbSB0aGUgZ2l2ZW4gcHJvdmlkZXJcbiAqXG4gKiBAcGFyYW0gd2FsbGV0IFRoZSBldGhlcnMgd2FsbGV0IHRvIGZ1bmRcbiAqIEBwYXJhbSBwcm92aWRlciBUaGUgcHJvdmlkZXIgd2hpY2ggaGFzIGNvbnRyb2wgb3ZlciB1bmxvY2tlZCwgZnVuZGVkIGFjY291bnRzIHRvIHRyYW5zZmVyIGZ1bmRzIGZyb21cbiAqIEBwYXJhbSBvdmVycmlkZXMgVHJhbnNhY3Rpb24gcGFyYW1ldGVycyB0byBvdmVycmlkZSB3aGVuIHNlbmRpbmcgdGhlIGZ1bmRpbmcgdHJhbnNhY3Rpb25cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGZ1bmRXYWxsZXQoXG4gIHdhbGxldDogZXRoZXJzLldhbGxldCxcbiAgcHJvdmlkZXI6IGV0aGVycy5wcm92aWRlcnMuSnNvblJwY1Byb3ZpZGVyLFxuICBvdmVycmlkZXM/OiBPbWl0PGV0aGVycy5wcm92aWRlcnMuVHJhbnNhY3Rpb25SZXF1ZXN0LCAndG8nIHwgJ2Zyb20nPixcbik6IFByb21pc2U8ZXRoZXJzLnByb3ZpZGVycy5UcmFuc2FjdGlvblJlY2VpcHQgfCB1bmRlZmluZWQ+IHtcbiAgY29uc3QgZGVidWcgPSBtYWtlRGVidWcoJ3dhbGxldDpmdW5kV2FsbGV0JylcblxuICAvLyBPVk0gaGFzIG5vIG5hdGl2ZSBFVEgvdmFsdWUsIHNvIHdhbGxldCBmdW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWRcbiAgaWYgKGlzT1ZNKCkpIHJldHVyblxuXG4gIGRlYnVnKCdmdW5kaW5nIHdhbGxldCcpXG5cbiAgZGVidWcoJ3JldHJlaXZpbmcgYWNjb3VudHMuLi4nKVxuXG4gIGNvbnN0IG5vZGVPd25lZEFjY291bnRzID0gYXdhaXQgcHJvdmlkZXIubGlzdEFjY291bnRzKClcbiAgZGVidWcoJ3JldHJlaXZlZCBhY2NvdW50czogJW8nLCBub2RlT3duZWRBY2NvdW50cylcblxuICBjb25zdCBzaWduZXIgPSBwcm92aWRlci5nZXRTaWduZXIobm9kZU93bmVkQWNjb3VudHNbMF0pXG5cbiAgY29uc3QgdHhQYXJhbXM6IGV0aGVycy5wcm92aWRlcnMuVHJhbnNhY3Rpb25SZXF1ZXN0ID0ge1xuICAgIHRvOiB3YWxsZXQuYWRkcmVzcyxcbiAgICB2YWx1ZTogZXRoZXJzLnV0aWxzLnBhcnNlRXRoZXIoJzEwJyksXG4gICAgLi4ub3ZlcnJpZGVzLFxuICB9XG4gIGRlYnVnKCdzZW5kaW5nIHR4IHdpdGggdGhlIGZvbGxvd2luZyBwYXJhbWV0ZXJzOiAlbycsIHR4UGFyYW1zKVxuICBjb25zdCB0eCA9IGF3YWl0IHNpZ25lci5zZW5kVHJhbnNhY3Rpb24odHhQYXJhbXMpXG5cbiAgZGVidWcoJ3dhaXRpbmcgb24gdHggJXMgdG8gY29tcGxldGUuLi4nLCB0eC5oYXNoKVxuICBjb25zdCByZWNlaXB0ID0gYXdhaXQgdHgud2FpdCgpXG4gIGRlYnVnKCd0eCAlcyBjb25maXJtZWQgd2l0aCB0eCByZWNlaXB0ICVvJywgdHguaGFzaCwgcmVjZWlwdClcbiAgcmV0dXJuIHJlY2VpcHRcbn1cbiJdfQ==